use crate::order;

/// The sequence of transactions that was done to match an order.
pub struct Log {
    pub(crate) events: Vec<Event>,
}

impl Log {
    pub(crate) fn new() -> Self {
        // TODO: What's a good default for this?
        Self { events: vec![] }
    }

    pub(crate) fn push(&mut self, event: Event) {
        self.events.push(event);
    }

    /// Walk the events generated by the log.
    pub(crate) fn iter(&self) -> impl Iterator<Item = &Event> {
        self.events.iter()
    }
}

#[derive(Debug)]
pub enum Event {
    /// An order that was added to the orderbook.
    Add(order::Order),
    /// Orders that have been cancelled.
    Cancel { id: order::Id },
    /// An order has been filled and is removed from the orderbook.
    ///
    /// Note that this does not mean that an order was completely filled,
    /// nor that the order was ever "on the book". Market orders will
    /// are passed into the book, are executed, and eventually leave the
    /// book without ever being written to it.
    Fill {
        id: order::Id,
        side: order::Side,
        unfilled_quantity: order::Quantity,
    },
    Match {
        /// The ID of the order that triggered a match, i.e. the order that is being filled by
        /// the passive order.
        active_order_id: crate::order::Id,
        /// The ID of the order in the orderbook that is filling the active order.
        passive_order_id: crate::order::Id,
        /// The price at which the transaction occured.
        price: crate::order::Price,
        /// The quantity that was exchanged.
        quantity: crate::order::Quantity,
    },
}

impl Event {
    pub fn as_added(&self) -> Option<&order::Order> {
        match self {
            Event::Add(order) => Some(order),
            _ => None,
        }
    }

    pub fn is_add(&self) -> bool {
        matches!(self, Event::Add(_))
    }

    pub fn is_fill(&self) -> bool {
        matches!(self, Event::Fill { .. })
    }
}
