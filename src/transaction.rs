use crate::order;

/// The sequence of transactions that was done to match an order.
#[derive(Debug)]
pub struct Log {
    pub(crate) events: Vec<Event>,
}

impl Log {
    pub(crate) fn new() -> Self {
        // TODO: What's a good default for this?
        Self { events: vec![] }
    }

    pub(crate) fn push<T>(&mut self, event: T)
    where
        Event: From<T>,
    {
        self.events.push(event.into());
    }

    /// Walk the events generated by the log.
    pub(crate) fn iter(&self) -> impl Iterator<Item = &Event> {
        self.events.iter()
    }
}

#[derive(Debug)]
pub enum Event {
    // FIXME: maybe adding a "Modify" variant and putting it in there together with other modifiers would be sufficient?:w
    Activate(order::Order),
    Add(order::Order),
    Cancel { id: order::Id },
    Fill(Fill),
    Match(Match),
}

impl Event {
    pub fn as_add(&self) -> Option<&order::Order> {
        match self {
            Self::Add(order) => Some(order),
            _ => None,
        }
    }

    pub fn as_fill(&self) -> Option<&Fill> {
        match self {
            Event::Fill(fill) => Some(fill),
            _ => None,
        }
    }

    pub fn as_match(&self) -> Option<&Match> {
        match self {
            // Self::Match(match) => Some(match),
            Self::Match(match_) => Some(match_),
            _ => None,
        }
    }

    pub fn is_add(&self) -> bool {
        matches!(self, Event::Add(_))
    }

    pub fn is_fill(&self) -> bool {
        matches!(self, Event::Fill { .. })
    }

    pub fn is_match(&self) -> bool {
        matches!(self, Event::Match(..))
    }
}

/// An order has been filled and is removed from the orderbook.
///
/// Note that this does not mean that an order was completely filled,
/// nor that the order was ever "on the book". Market orders will
/// are passed into the book, are executed, and eventually leave the
/// book without ever being written to it.
#[derive(Debug, PartialEq, Eq)]
pub struct Fill {
    /// The id of the filled order.
    pub id: order::Id,
    /// The side of the filled order.
    pub side: order::Side,
    /// The quantity of the order that remained unfilled after exiting the book.
    pub unfilled_quantity: order::Quantity,
}

impl From<Fill> for Event {
    fn from(value: Fill) -> Self {
        Self::Fill(value)
    }
}

#[derive(Debug, PartialEq, Eq)]
pub struct Match {
    /// The ID of the order that triggered a match, i.e. the order that is being filled by
    /// the passive order.
    pub active_order_id: crate::order::Id,
    /// The ID of the order in the orderbook that is filling the active order.
    pub passive_order_id: crate::order::Id,
    /// The price at which the transaction occured.
    pub price: crate::order::Price,
    /// The quantity that was exchanged.
    pub quantity: crate::order::Quantity,
}

impl From<Match> for Event {
    fn from(value: Match) -> Self {
        Self::Match(value)
    }
}
